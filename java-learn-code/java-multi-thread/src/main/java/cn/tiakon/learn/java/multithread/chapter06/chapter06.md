# 8. 双刃剑：多线程可能导致安全、性能问题 ？

1. 考考你
   - 一共有哪几类线程安全问题？
   - 哪些场景需要额外注意线程安全问题？
   - 什么是多线程带来的上下文切换（阿里面试题）？



## 1. 线程安全

#### 1.1 什么是线程安全

《Java 并发编程实战》的作者Brian Goetz对“线程安全”有一个比较恰当的定义：

当多个线程访问一个对象时，如果**不用考虑**这些线程在运行时环境下的调度和交替执行，**也不需要进行额外的同步**，或者在调用方进行任何其他的协调操作，调用

这个对象的行为都可以获得**正确的结果**，那这个对象就是线程安全的。

我的翻译：

​	不管业务中遇到怎么的多个线程访问某对象或某个方法的情况，而在编程这业务逻辑的时候，**都不需要额外做任何额外的处理**（也就是可以像单线程一样），程

序也可以正常运行（不会因为多线程而出错），就可以称为线程安全。

- 线程不安全：get同时set、额外同步。
- 全都线程安全？运行速度、设计成本、trade off。
- 完全不用于多线程：不过度设计。



#### 1.2 线程安全会导致哪些问题，怎么避免？

数据争用：两个线程同时写一个变量，造成写入错误，要么被覆盖，要么写入错误。数据读写由于同时写，会造成错误数据。

竞争条件：执行循序上的错误。（即时不是同时写造成的错误数据，由于顺序原因依然会造成错误，例如在写入前就读取了。）

- 运行结果错误：a++多线程下出现小时的请求现象，属于read-modify-write。
- 活跃性问题：死锁、活锁、饥饿
- ![01-死锁](R:\code\project-source\notes-and-code-about-learning\java-learn-code\java-multi-thread\src\main\java\cn\tiakon\learn\java\multithread\chapter06\01-死锁.png)
- 对象发布和初始化的时候的安全问题
  - 什么是对象发布？：让这个对象超过类的范围之内去使用。 
    1. 声明为public。
    2. return一个对象
    3. 把对象作为参数传递到其它类的方法中。
  - 什么是逸出？
    1. 方法返回一个private对象（private本意是不让外部访问）；解决办法：返回副本。
    2. 还未完成初始化就把对象提供给外界，比如：（解决办法：工厂模式）
       - 在构造函数中未初始化完毕就this赋值。
       - 隐式逸出--注册监听事件。
       - 构造函数中运行线程。
- 各种需要考虑线程安全的情况：
  1. 访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等
  2. 所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：（本质上都是因为该操作不是一个原子操作）
     - read-modify-write操作：一个线程读取了一个共享数据，并在此基础上更新该数据。
     - check-then-action操作：一个线程读取了一个共享数据，并在此基础上决定其下一个操作。
  3. 不同的数据之间存在绑定关系。（IP、端口号）
  4. 我们使用其他类的时候，如果对象没有声明自己是线程安全的。





## 2.双刃剑：多线程会导致的问题？

- 性能问题有哪些体现、什么是性能问题？

  - 服务响应慢、吞吐量低、资源消耗（例如内存）过高等；

  - 虽然不是结果错误，但是依然危害巨大；

  - 引入多线程不能本末倒置。

    

  

## 3.为什么多线程会带来性能问题？

#### 3.1 调度：上下文切换

1. 什么是**上下文**切换：
   - 当某一个线程执行`Thread.Sleep()`,线程调度器会将线程阻塞，然后让另一个等待cpu资源的线程进入Runnable状态，该动作即为上下文切换。通常发生一次上下文切换会消耗上5000~10000cpu时钟周期，大概是几微秒，对cpu而言已是非常大的开销。
2. 什么时候会发什么线程调度：
   - 可运行的线程数超过了cpu的数量，操作系统就会调度线程，以便让每个线程都能运行。
3. 什么是上下文：
   - 程序执行环境的快照。主要跟计数器相关，首先将当前线程挂起，并将当前线程状态记录在内存某处，该状态即为上下文。上下文包含：线程执行到哪一个指令、指令位置在哪等，还包括程序计数器等。切换回来后。这些内容都是，线程切换回来后所必须的内容。
   - 上下文切换可以认为是内核（操作系统内核）在cpu上对于进程（包括线程）进行一下活动：
     1. 挂起一个进程，将这个进程在cpu的状态(上下文)存储于内存中的某处。
     2. 在内存中检索下一个进程的上下文并将其在cpu的寄存器中恢复。
     3. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
4. **缓存**开销：导致原来的缓存失效，cpu重新缓存。
   - cpu在执行某个线程时，会缓存数据到cpu中来提升性能。重新调度线程后会导致在cpu中的缓存失效。cup会防止过于频繁的上下文切换，通过设置最小执行时间（两次上下文切换之间不能小于这个最小预支，否则上下文切换的开销会大于程序的执行）。
5. 何时会导致**密集的上下文**切换：抢锁、IO
   - 频繁的竞争锁
   - 经常IO读写
   - 有些原因导致的频繁的IO阻塞
   - 大量cpu长时间计算，上下文切换就会比较少

#### 3.2 协作：内存同步

- 编译器，cpu会优化程序，指令重排序，提高缓存效率，优化锁，删除没必要的锁。
- Java内存模型规定，多线程中使用synchronized、volatile会使线程缓存失效，需要与主内存保持同步，因此降低了效率。
- 为了数据的正确性，同步手段往往会使用禁止编译器优化、使cpu内的缓存失效。

## 4.常见面试问题？



1. 你知道有哪些线程不安全的情况？
   - 1.2，的四种情况。 
2. 平时哪些情况下需要额外注意线程安全问题？
   - 各种需要考虑线程安全的情况
3. 什么是多线程的上下文切换？
   - 看上文。